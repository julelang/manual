import{_ as s,o as e,c as n,Q as a}from"./chunks/framework.7cd3ab18.js";const b=JSON.parse('{"title":"std::conv","description":"","frontmatter":{},"headers":[],"relativePath":"std/conv.md","filePath":"std/conv.md"}'),t={name:"std/conv.md"},o=a('<h1 id="std-conv" tabindex="-1">std::conv <a class="header-anchor" href="#std-conv" aria-label="Permalink to &quot;std::conv&quot;">​</a></h1><h2 id="globals" tabindex="-1">Globals <a class="header-anchor" href="#globals" aria-label="Permalink to &quot;Globals&quot;">​</a></h2><h3 id="const-int-size" tabindex="-1"><code>const INT_SIZE</code> <a class="header-anchor" href="#const-int-size" aria-label="Permalink to &quot;`const INT_SIZE`&quot;">​</a></h3><p>Is the size in bits of an int or uint value.</p><h2 id="functions" tabindex="-1">Functions <a class="header-anchor" href="#functions" aria-label="Permalink to &quot;Functions&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">conv_bool</span><span style="color:#E1E4E8;">(s: </span><span style="color:#F97583;">str</span><span style="color:#E1E4E8;">): (</span><span style="color:#F97583;">bool</span><span style="color:#E1E4E8;">, ConvError)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">fmt_bool</span><span style="color:#E1E4E8;">(b: </span><span style="color:#F97583;">bool</span><span style="color:#E1E4E8;">): </span><span style="color:#F97583;">str</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns &quot;true&quot; or &quot;false&quot; according to the value of b.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">fmt_uint</span><span style="color:#E1E4E8;">(i: </span><span style="color:#F97583;">u64</span><span style="color:#E1E4E8;">, base: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">): </span><span style="color:#F97583;">str</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns the string representation of i in the given base, for 2 &lt;= base &lt;= 36. The result uses the lower-case letters &#39;a&#39; to &#39;z&#39; for digit values &gt;= 10.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">fmt_int</span><span style="color:#E1E4E8;">(i: </span><span style="color:#F97583;">i64</span><span style="color:#E1E4E8;">, base: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">): </span><span style="color:#F97583;">str</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns the string representation of i in the given base, for 2 &lt;= base &lt;= 36. The result uses the lower-case letters &#39;a&#39; to &#39;z&#39; for digit values &gt;= 10.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">itoa</span><span style="color:#E1E4E8;">(i: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">): </span><span style="color:#F97583;">str</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Is equivalent to fmt_int(i64(i), 10).</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">fmt_float</span><span style="color:#E1E4E8;">(f: </span><span style="color:#F97583;">f64</span><span style="color:#E1E4E8;">, fmt: </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">, prec: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, bit_size: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">): </span><span style="color:#F97583;">str</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bit_size bits (32 for f32, 64 for f64).</p><p>The format fmt is one of<br> &#39;b&#39; (-ddddp±ddd, a binary exponent),<br> &#39;e&#39; (-d.dddde±dd, a decimal exponent),<br> &#39;E&#39; (-d.ddddE±dd, a decimal exponent),<br> &#39;f&#39; (-ddd.dddd, no exponent),<br> &#39;g&#39; (&#39;e&#39; for large exponents, &#39;f&#39; otherwise),<br> &#39;G&#39; (&#39;E&#39; for large exponents, &#39;f&#39; otherwise),<br> &#39;x&#39; (-0xd.ddddp±ddd, a hexadecimal fraction and binary exponent), or<br> &#39;X&#39; (-0Xd.ddddP±ddd, a hexadecimal fraction and binary exponent).</p><p>The precision prec controls the number of digits (excluding the exponent) printed by the &#39;e&#39;, &#39;E&#39;, &#39;f&#39;, &#39;g&#39;, &#39;G&#39;, &#39;x&#39;, and &#39;X&#39; formats. For &#39;e&#39;, &#39;E&#39;, &#39;f&#39;, &#39;x&#39;, and &#39;X&#39;, it is the number of digits after the decimal point. For &#39;g&#39; and &#39;G&#39; it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that parse_float will return f exactly.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">parse_int</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> s: </span><span style="color:#F97583;">str</span><span style="color:#E1E4E8;">, base: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> bit_size: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">): (</span><span style="color:#F97583;">i64</span><span style="color:#E1E4E8;">, ConvError)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.</p><p>The string may begin with a leading sign: &quot;+&quot; or &quot;-&quot;.</p><p>If the base argument is 0, the true base is implied by the string&#39;s prefix following the sign (if present): 2 for &quot;0b&quot;, 8 for &quot;0&quot; or &quot;0o&quot;, 16 for &quot;0x&quot;, and 10 otherwise.</p><p>The bit_size argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, i8, i16, i32, and i64. If bit_size is below 0 or above 64, an error is returned.</p><p>The errors that parse_int returns have concrete type ConvError. If s is empty or contains invalid digits, err = ConvError.InvalidSyntax and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err = ConvError.OutOfRange and the returned value is the maximum magnitude integer of the appropriate bit_size and sign.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">parse_uint</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> s: </span><span style="color:#F97583;">str</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> base: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> bit_size: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">): (</span><span style="color:#F97583;">u64</span><span style="color:#E1E4E8;">, ConvError)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Is like parse_int but for unsigned numbers. A sign prefix is not permitted.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">parse_float</span><span style="color:#E1E4E8;">(s: </span><span style="color:#F97583;">str</span><span style="color:#E1E4E8;">, bit_size: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">): (</span><span style="color:#F97583;">f64</span><span style="color:#E1E4E8;">, ConvError)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Converts the string s to a floating-point number with the precision specified by bit_size: 32 for f32, or 64 for f64. When bit_size=32, the result still has type f64, but it will be convertible to f32 without changing its value.</p><p>Accepts decimal and hexadecimal floating-point numbers as defined by the Jule syntax for [floating-point literals]. If s is well-formed and near a valid floating-point number, returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.)</p><p>The errors that returns have concrete type ConvError.</p><p>If s is not syntactically well-formed, returns err = ConvError.InvalidSyntax.</p><p>If s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, Returns f = ±inf, err = ConvError.OutOfRange.</p><p>Recognizes the string &quot;nan&quot;, and the (possibly signed) strings &quot;inf&quot; and &quot;infinity&quot; as their respective special floating point values. It ignores case when matching.</p><h2 id="enums" tabindex="-1">Enums <a class="header-anchor" href="#enums" aria-label="Permalink to &quot;Enums&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">enum</span><span style="color:#E1E4E8;"> ConvError</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Error codes of conv package.</p><p><strong>Fields:</strong></p><ul><li><code>Ok</code>: No problem</li><li><code>OutOfRange</code>: Indicates that a value is out of range for the target type</li><li><code>InvalidSyntax</code>: Indicates that a value does not have the right syntax for the target type</li><li><code>InvalidBase</code>: Indicates that a base is invalid</li><li><code>InvalidBitSize</code>: Indicates that a bit size is invalid</li></ul>',47),l=[o];function r(i,p,c,d,u,E){return e(),n("div",null,l)}const y=s(t,[["render",r]]);export{b as __pageData,y as default};
