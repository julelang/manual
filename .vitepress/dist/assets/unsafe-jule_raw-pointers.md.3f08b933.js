import{_ as s,o as a,c as n,Q as e}from"./chunks/framework.7cd3ab18.js";const h=JSON.parse('{"title":"Raw Pointers","description":"","frontmatter":{},"headers":[],"relativePath":"unsafe-jule/raw-pointers.md","filePath":"unsafe-jule/raw-pointers.md"}'),o={name:"unsafe-jule/raw-pointers.md"},p=e(`<h1 id="raw-pointers" tabindex="-1">Raw Pointers <a class="header-anchor" href="#raw-pointers" aria-label="Permalink to &quot;Raw Pointers&quot;">​</a></h1><h2 id="derefence-a-raw-pointer" tabindex="-1">Derefence a Raw Pointer <a class="header-anchor" href="#derefence-a-raw-pointer" aria-label="Permalink to &quot;Derefence a Raw Pointer&quot;">​</a></h2><p>Unsafe Jule allows deference raw pointers.</p><p>For example:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">200</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> ptr </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">x</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">unsafe</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">ptr) }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Note that no safety is provided in this regard. Pointers can benefit you, but you have to provide safety yourself. You need to be wary of dangling pointers, buffer overflows, and similar memory issues.</p><h2 id="postfixes-for-raw-pointers" tabindex="-1">Postfixes for Raw Pointers <a class="header-anchor" href="#postfixes-for-raw-pointers" aria-label="Permalink to &quot;Postfixes for Raw Pointers&quot;">​</a></h2><p>Unsafe Jule supports postfixes for raw pointers.</p><p>For example:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">print_slice_components_with_unsafe</span><span style="color:#E1E4E8;">(slc: []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">unsafe</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> ptr </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">slc[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> end </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">slc[slc.len</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">        end</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> ptr </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> end {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">ptr)</span></span>
<span class="line"><span style="color:#E1E4E8;">            ptr</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="indexing-with-raw-pointers" tabindex="-1">Indexing with Raw Pointers <a class="header-anchor" href="#indexing-with-raw-pointers" aria-label="Permalink to &quot;Indexing with Raw Pointers&quot;">​</a></h2><p>This is especially true if you have a pointer to an array (for example, an array pointer allocated with <code>std::mem::c</code> package), which allows you to use the pointer just like an array. Maybe you would prefer to use a wrapper to help with the length for the offset, as they are just raw pointers and don&#39;t have a way to get the lengths right away like in Jule&#39;s slice or array structures.</p><p>The fact that this operation is covered by Unsafe Jule is not only because it has widespread pointer unsafety, but also because there is a possibility of overflow and this is not checked. For example, slice and array are safe and controlled in this regard.</p><p>When you have an array of pointers, it can be interpreted semantically like this: It is a pointer to the component type, as the pointer usually points to one of the memory areas. So think of it like a pointer to the field of an element of an array. Indexing is sensitive to the data type according to the offset, skipping that much space in the memory, finding the position of the offset and selecting that area.</p><p>To better understand data type sampling, array pointers can be interpreted as:</p><ul><li><code>*int</code> = <code>[]int</code></li><li><code>*str</code> = <code>[]str</code></li></ul><p>For example:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">ptr[</span><span style="color:#79B8FF;">9</span><span style="color:#E1E4E8;">]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Suppose the variable <code>ptr</code> is <code>*int</code>. Let this pointer be an array pointer. The above expression takes the data at index 9 of this array.</p><h2 id="cast-raw-pointers" tabindex="-1">Cast Raw Pointers <a class="header-anchor" href="#cast-raw-pointers" aria-label="Permalink to &quot;Cast Raw Pointers&quot;">​</a></h2><p>You can cast a pointer to an integer with valid integer types or cast a raw pointer from an integer. However, you can also cast a pointer to a pointer of different type.</p><p>For example:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> ptr: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> unsafe_ptr </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">unsafe</span><span style="color:#E1E4E8;"> { (</span><span style="color:#F97583;">*str</span><span style="color:#E1E4E8;">)(ptr) }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="get-smart-pointer-from-raw-pointer" tabindex="-1">Get Smart Pointer from Raw Pointer <a class="header-anchor" href="#get-smart-pointer-from-raw-pointer" aria-label="Permalink to &quot;Get Smart Pointer from Raw Pointer&quot;">​</a></h2><p>From raw pointers, you can obtain smart pointers (aka reference types). One casting is sufficient for this. Of course, this conversion is not safe. Dangling pointers are not checked. Smart pointers continue to protect you only regarding nil pointers. However, smart pointers obtained in this way do not perform reference counting.</p><p>It is an Unsafe Jule feature that can be used to achieve optimization for purposes such as eliminating reference counting for a statically stored reference type. In addition, you legitimize the use of raw pointers in Safe Jule and eliminate the need to use Unsafe Jule for issues such as dereferencing.</p><p>For example:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> x: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> y </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">unsafe</span><span style="color:#E1E4E8;"> { (</span><span style="color:#F97583;">&amp;int</span><span style="color:#E1E4E8;">)(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">x) }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">y </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">20</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(x)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="pass-pointer-to-reference" tabindex="-1">Pass Pointer to Reference <a class="header-anchor" href="#pass-pointer-to-reference" aria-label="Permalink to &quot;Pass Pointer to Reference&quot;">​</a></h2><p>If you want to send your pointers to a reference parameter, you can do so with a simple pointer dereferencing. You are aware of the insecurity as this is already an action you would take using Unsafe Jule.</p><p>For example:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#79B8FF;">my_function</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">unsafe</span><span style="color:#E1E4E8;"> { </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">my_pointer })</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>`,32),l=[p];function r(t,i,c,E,y,u){return a(),n("div",null,l)}const f=s(o,[["render",r]]);export{h as __pageData,f as default};
