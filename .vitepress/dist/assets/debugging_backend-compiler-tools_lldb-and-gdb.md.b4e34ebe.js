import{_ as e,o as a,c as n,Q as o}from"./chunks/framework.7cd3ab18.js";const h=JSON.parse('{"title":"LLDB and GDB","description":"","frontmatter":{},"headers":[],"relativePath":"debugging/backend-compiler-tools/lldb-and-gdb.md","filePath":"debugging/backend-compiler-tools/lldb-and-gdb.md"}'),s={name:"debugging/backend-compiler-tools/lldb-and-gdb.md"},t=o(`<h1 id="lldb-and-gdb" tabindex="-1">LLDB and GDB <a class="header-anchor" href="#lldb-and-gdb" aria-label="Permalink to &quot;LLDB and GDB&quot;">​</a></h1><p>LLDB and GDB can be considered as the best debugging tools for C++ backend. LLDB for LLVM compilers like Clang, GDB for GCC have a pretty close experience and can help you debug many problems.</p><p>Since Jule catches some errors at runtime, you may not be able to fully benefit from these tools. Because Jule panics are not caught by these tools. By disabling Jule&#39;s safety, you need to allow errors to occur that these tools can catch.</p><p>To disable Jule&#39;s safety you need to edit the IR. If you add <code>#define __JULE_DISABLE__SAFETY</code> at the beginning of the IR code, Jule will not perform safety checks.</p><h2 id="compilation" tabindex="-1">Compilation <a class="header-anchor" href="#compilation" aria-label="Permalink to &quot;Compilation&quot;">​</a></h2><p>If you want to have an efficient debugging experience in these tools, disabling the optimizations of your backend compiler is a good choice. If you know that the problem is caused by optimizations and you are not trying to understand it, turning on optimizations may make your job difficult. However, to request debug information for Clang or GCC, compile with <code>-g</code> option.</p><h2 id="basic-debugging" tabindex="-1">Basic Debugging <a class="header-anchor" href="#basic-debugging" aria-label="Permalink to &quot;Basic Debugging&quot;">​</a></h2><p>Now here&#39;s an example with Clang and LLDB for a simple debugging example. The experience and commands between LLDB and GDB are often the same or quite similar.</p><p>Here is our basic program:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s: []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(s[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>The above program is clearly one in which we create problems for ourselves. At work time, Jule panics due to safety measures. But we may not be able to obtain enough information, such as location information. This example focuses on how such an error can be understood in practice with LLDB and GDB.</p><p>First of all, we obtain the IR code by transpiling this Jule code. And then, we add <code>#define __JULE_DISABLE__SAFETY</code> at the top of the IR code to turn off Jule security measures. This will prevent the program from panicking at runtime and accessing the invalid memory address, making the error handleable and catchable. Otherwise, the program will panic and be terminated by the Jule runtime, and LLDB or GDB will not be able to understand the problem here.</p><p>After making the necessary addition, we can find the recommended compilation command in the IR file for a quick start. Take it and compile your IR code with your backend compiler by adding the <code>-g</code> option.</p><p>Then open the compiled executable with LLDB or GDB. Your command looks like this:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">lldb &lt;exec&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Then run <code>r</code> to execute your program. If your program needs command line arguments, provide them. Your command looks lise this:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">(lldb) r &lt;args&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Then, if there is any problem, you can get more detailed information about it. The nil memory usage problem, which was deliberately created in the sample code, may not occur directly in the same location, so the problem you will experience may refer to codes within the Jule API or something like that.</p><p>To see how your algorithm is progressing and get better information, look at the backtrace and examine the call-stack. Execute <code>bt</code> command to view the backtrace. Your command looks lise this:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">(lldb) bt</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>The backtrace progresses from the last called function to the first called function (commonly the entry point). By following the trace, it will be easier to detect where in your own code is causing the problem.</p>`,21),l=[t];function i(r,c,p,d,u,m){return a(),n("div",null,l)}const g=e(s,[["render",i]]);export{h as __pageData,g as default};
