import{_ as e,o as t,c as s,Q as n}from"./chunks/framework.7cd3ab18.js";const h=JSON.parse('{"title":"std::vec","description":"","frontmatter":{},"headers":[],"relativePath":"std/vec.md","filePath":"std/vec.md"}'),o={name:"std/vec.md"},c=n('<h1 id="std-vec" tabindex="-1">std::vec <a class="header-anchor" href="#std-vec" aria-label="Permalink to &quot;std::vec&quot;">​</a></h1><h2 id="structs" tabindex="-1">Structs <a class="header-anchor" href="#structs" aria-label="Permalink to &quot;Structs&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> Vec[T]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Wrapper for dynamic array.<br> Uses capacity for performanc\\e.<br> Grows capacity if necessary.<br> But always allocates more for future \\pushes.<br> The elements are stored contiguously.</p><p>Deallocates itself when destroyed.</p><p>Vectors aren&#39;t use shared allocation between them.<br> Allocates new space and copies (not deep copy) items into space.</p><p><strong>Methods:</strong></p><p><code>static fn new(cap: int): Vec[T]</code> <br> Allocate new vector with capacity.</p><p><code>fn len(self): int</code><br> Returns length.</p><p><code>fn cap(self): int</code><br> Returns capacity.</p><p><code>set_len(mut self, n: int)</code><br> Sets length.<br> Sets length to zero if n &lt; 0.<br> Don&#39;t set length if n &gt;= length of vector.</p><p><code>fn at(mut self, i: int): T</code><br> Returns item by index.</p><p><code>fn set(mut self, i: int, mut item: T)</code><br> Set element by index.</p><p><code>fn dealloc(mut self)</code><br> Deallocates heap.</p><p><code>fn push(mut self, mut item: T)</code><br> Push item to end of heap.</p><p><code>fn push(mut self, mut items: ...T)</code><br> Push items to end of heap.</p><p><code>fn push_front(mut self, mut item: T)</code><br> Push item to front of heap.</p><p><code>fn merge(mut self, mut vec: Vec[T])</code><br> Merge items to end of heap.</p><p><code>fn merge_front(mut self, mut vec: Vec[T])</code><br> Merge items to front of heap.</p><p><code>fn remove_range(mut self, start: int, n: int)</code><br> Remove range from heap.</p><p><code>fn insert(mut self, i: int, mut item: T)</code><br> Insert item by index.</p><p><code>fn insert(mut self, start: int, end: int): Vec[T]</code><br> Slice between indexes except end position.</p>',22),a=[c];function r(p,d,i,l,u,f){return t(),s("div",null,a)}const b=e(o,[["render",r]]);export{h as __pageData,b as default};
