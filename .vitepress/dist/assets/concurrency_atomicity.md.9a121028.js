import{_ as s,o as a,c as n,Q as e}from"./chunks/framework.7cd3ab18.js";const u=JSON.parse('{"title":"Atomicity","description":"","frontmatter":{},"headers":[],"relativePath":"concurrency/atomicity.md","filePath":"concurrency/atomicity.md"}'),l={name:"concurrency/atomicity.md"},o=e(`<h1 id="atomicity" tabindex="-1">Atomicity <a class="header-anchor" href="#atomicity" aria-label="Permalink to &quot;Atomicity&quot;">â€‹</a></h1><p>Atomicity is important for concurrency. An atomic operation guarantees that the memory accesses will be sequential. At the very least, you can be sure that their in-memory operation will produce the correct result.</p><p>Here is an example code:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> n: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">add_to_n</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    n</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1000000</span><span style="color:#E1E4E8;">; j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">co</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">add_to_n</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(n)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>What is missing in the above code? You probably noticed that the <code>WaitGroup</code> struct described in the previous section should be used. Because exactly <code>1000000</code> thread is created, but there is no guarantee that any of them will finish their execution.</p><p>Well, we will wait for the threads to finish executing with <code>WaitGroup</code> structure. So is there another problem? Of course we do, we need atomic access because we have a race condition for <code>n</code> variable.</p><p>The above code creates threads that increment the global <code>n</code> variable by 1. As a result, when all threads are completed, the value of the <code>n</code> variable should have the value <code>1000000</code>. However, contrary to expectations, even if all threads are expected to be executed, the result may not be <code>1000000</code> in a healthy way. The reason for this is the race condition. Race condition occurs when more than one thread tries to access a data field at the same time. In other words, according to the scenario above, two or more threads can read data of variable <code>n</code> at the same time. This means that because a thread reads the same data, it will increase the old data by one, that is, it does not take any action that will affect the result.</p><p>Atomic accesses can be used to synchronize memory accesses. An atomic process locks the corresponding memory space so that it can only be accessed by one thread at a time. This causes the increment and read operations to be performed safely. Because threads wait for the relevant memory area to be unlocked, and only one of them can take over this lock and perform operations at a time.</p><p>Jule provides the <code>std::sync::atomic</code> package for atomicity as standard. Now let&#39;s take a look at the above code secured with <code>WaitGroup</code> and atomic operations:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">use</span><span style="color:#E1E4E8;"> std::sync::{WaitGroup}</span></span>
<span class="line"><span style="color:#F97583;">use</span><span style="color:#E1E4E8;"> std::sync::atomic::{AtomicInt, MemoryOrder}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> n: AtomicInt </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> AtomicInt.</span><span style="color:#79B8FF;">new</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">add_to_n</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> wg: </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">WaitGroup) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">unsafe</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">defer</span><span style="color:#E1E4E8;"> { wg.</span><span style="color:#79B8FF;">done</span><span style="color:#E1E4E8;">() }</span></span>
<span class="line"><span style="color:#E1E4E8;">    n.</span><span style="color:#79B8FF;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, MemoryOrder.Relaxed)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> wg </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> WaitGroup{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1000000</span><span style="color:#E1E4E8;">; j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        wg.</span><span style="color:#79B8FF;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">co</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">add_to_n</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">wg)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    wg.</span><span style="color:#79B8FF;">wait</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(n.</span><span style="color:#79B8FF;">load</span><span style="color:#E1E4E8;">(MemoryOrder.Relaxed))</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>The above code is waiting for all threads to terminate with <code>WaitGroup</code>. That&#39;s nice, but is the variable <code>n</code> safely incremented? The answer is yes, it is now an atomic operation.</p>`,11),p=[o];function t(c,r,i,E,y,d){return a(),n("div",null,p)}const b=s(l,[["render",t]]);export{u as __pageData,b as default};
