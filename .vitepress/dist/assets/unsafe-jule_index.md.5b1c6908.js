import{_ as e,o as a,c as t,Q as i}from"./chunks/framework.7cd3ab18.js";const y=JSON.parse('{"title":"Unsafe Jule","description":"","frontmatter":{},"headers":[],"relativePath":"unsafe-jule/index.md","filePath":"unsafe-jule/index.md"}'),n={name:"unsafe-jule/index.md"},o=i('<h1 id="unsafe-jule" tabindex="-1">Unsafe Jule <a class="header-anchor" href="#unsafe-jule" aria-label="Permalink to &quot;Unsafe Jule&quot;">​</a></h1><p>We know, Jule is safe. But you are a developer who knows what you are doing, you are confident. There is the <code>unsafe</code> keyword for you. With this keyword, you can circumvent Jule&#39;s safety and engage in unsafe behavior. This is understandably insecure and can compromise your program&#39;s safety. All responsibility in this matter belongs to you as the developer.</p><p>The reason for the unsafe Jule is that the computer is basically unsafe by nature. Sometimes you need this unsafety. If Jule didn&#39;t provide this, it would take more effort to solve some things with Jule. Maybe you could take an approach like using C++ interoperability, but is the effort really necessary? C++ interoperability is a nice feature and in some cases provides significant benefits. But having a C++ dependency of your Jule code exposed isn&#39;t always a good thing. It is very important that you can write pure Jule. As a developer, the only time you should feel like you should use C++ interoperability is when you really need to use C++ code.</p><p>Unsafe Jule can also allow you to get performance gains and better memory optimization. For example, if you are sure that a pointer never, ever needs to be guaranteed, you can achieve significant gains by obtaining this pointer with Unsafe Jule. Because that means there will be no new memory allocations and reference counting.</p><h2 id="unsafe-benefits" tabindex="-1">Unsafe Benefits <a class="header-anchor" href="#unsafe-benefits" aria-label="Permalink to &quot;Unsafe Benefits&quot;">​</a></h2><p>The mentioned <code>unsafe</code> keyword allows us to use these powers. If you don&#39;t switch to insecure Jule, secure Jule will not allow you to engage in unsafe behavior.</p><p>Benefits of Unsafe Jule:</p><ul><li>Break immutability</li><li>Deference a raw pointer</li><li>Postfixes for raw pointers</li><li>Indexing with raw pointers</li><li>Cast raw pointers</li><li>Get smart pointer from raw pointer</li><li>Call unsafe functions or methods</li><li>Concurrent calls with reference parameters</li><li>Pass pointer to reference</li><li>Access reference from parent scope</li><li><a href="/integrated-jule/backend-emits.html">Emit backend code</a></li><li><a href="/packages/3rd-party-packages/deprecation.html">Use deprecated code</a></li></ul><p>Note that this does not lead to a completely unsafe use of Jule. Other than the listed unsafe behaviors, Safe Jule will continue to show itself. This means you get a level of safety even with unsafe blocks.</p>',9),s=[o];function r(l,u,c,f,d,h){return a(),t("div",null,s)}const m=e(n,[["render",r]]);export{y as __pageData,m as default};
