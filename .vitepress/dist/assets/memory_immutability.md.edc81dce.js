import{_ as e,o as a,c as s,Q as t}from"./chunks/framework.7cd3ab18.js";const y=JSON.parse('{"title":"Immutability","description":"","frontmatter":{},"headers":[],"relativePath":"memory/immutability.md","filePath":"memory/immutability.md"}'),i={name:"memory/immutability.md"},n=t(`<h1 id="immutability" tabindex="-1">Immutability <a class="header-anchor" href="#immutability" aria-label="Permalink to &quot;Immutability&quot;">​</a></h1><p>One approach of the compiler from its security obsessions is that by default variables are immutable. You&#39;ve probably seen in the structure documentations that the compiler insists on using a reference to the reference receiver. This is just one of the compiler&#39;s security obsessions. But right now, we&#39;re taking a look at another similar obsession: immutability by default!</p><p>The fact that a variable is immutable by default requires that you do so consciously if you want to change it. Let&#39;s see why this is a security obsession for the compiler:</p><p>Jule has data types in which it is mutable. These are:</p><ul><li>Pointer</li><li>Slice</li><li>Reference</li><li>Array, structure or etc. which is has mutable type</li></ul><p>These are types that point to commonalities among the variables with which they are shared. You may want to ensure that one of these types has not changed. You are safe about this as variables are immutable by default. This is possible if you want it to be mutable. But before we get into how this is done, let&#39;s take a look at how obsessed the compiler is with immutability.</p><p>If you are using a mutable data type and your data type is in an immutable variable, the compiler will never allow you to assign it to a mutable variable. If the compiler allows it, you will lose its immutability. The value of the immutable variable can be changed with the new mutable variable.</p><p>For the same reason, the compiler will force you to return a mutable variable if you also have one of these data types as a return expression. This is precisely because this variable can change. The compiler has no idea whether a data type is mutable. All are basically immutable, with the exception of the ones listed above.</p><p>An immutable variable with mutable data type returned from the function then poses a unsafety. Because it is not possible to specify it as immutable in return data type. That&#39;s why the compiler assumes that the return value can change, and shows you one of its strict obsessions about it: if you&#39;re returning, please use a mutable variable. Even if you&#39;re just returning the variable, the compiler doesn&#39;t want to understand it. According to the compiler, if that variable is an immutable and is also used within the function, the immutable obtained instance obtained from the return value may break this immutability. Even if there is no such thing, the compiler will continue to insist on this.</p><p>Okay, so why doesn&#39;t the compiler implement immutability by default only for those data types? This is a good question. The answer lies in the compiler wanting to be stable. It is a mental overhead during the development phase that the developer has to constantly consider these data types. This stability of the compiler ensures that the developer always knows that all variables are immutable by default. This also helps the developer to understand what he or she is changing and will change while developing and reading algorithms. It is more obvious which variables should be paid attention to, especially when using concurrency.</p><h2 id="responsive-immutability" tabindex="-1">Responsive Immutability <a class="header-anchor" href="#responsive-immutability" aria-label="Permalink to &quot;Responsive Immutability&quot;">​</a></h2><p>Responsive immutability is the state of protection when immutability is guaranteed. For example, if a slice is guaranteed to have an immutable memory area at the time it is created, it is allowed to have mutable types stored in the immutable memory area, even though it is a mutable type.</p><p>For example:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> Test {</span></span>
<span class="line"><span style="color:#E1E4E8;">    slice: []</span><span style="color:#F97583;">int</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Test{</span></span>
<span class="line"><span style="color:#E1E4E8;">        slice: x,</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(s)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>In the example above, the variable <code>x</code> is an immutable slice. However, when a mutable field is assigned, it becomes possible to change immutable data because it is mutable. This is clearly a violation of immutability. However, it is guaranteed that the <code>Test</code> structure created for the <code>s</code> variable will be immutable because the <code>s</code> variable to which it will be assigned is immutable. Your compiler will be fine with this. However, if immutability is not guaranteed or the compiler cannot understand it, you will be explicitly warned about mutability.</p>`,15),l=[n];function o(r,p,c,u,m,h){return a(),s("div",null,l)}const d=e(i,[["render",o]]);export{y as __pageData,d as default};
