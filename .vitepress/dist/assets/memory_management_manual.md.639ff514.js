import{_ as s,o as a,c as n,Q as e}from"./chunks/framework.7cd3ab18.js";const d=JSON.parse('{"title":"Manual Memory Management","description":"","frontmatter":{},"headers":[],"relativePath":"memory/management/manual.md","filePath":"memory/management/manual.md"}'),l={name:"memory/management/manual.md"},p=e(`<h1 id="manual-memory-management" tabindex="-1">Manual Memory Management <a class="header-anchor" href="#manual-memory-management" aria-label="Permalink to &quot;Manual Memory Management&quot;">​</a></h1><p>Jule has functionalities that enable manual memory management. But this has some points that create unsafety.</p><h2 id="with-std-mem" tabindex="-1">With <code>std::mem</code> <a class="header-anchor" href="#with-std-mem" aria-label="Permalink to &quot;With \`std::mem\`&quot;">​</a></h2><p>The <code>Heap</code> struct included in the standard library allows you to manually allocate and release space. It is relatively safer than raw pointers.</p><p>For example:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">use</span><span style="color:#E1E4E8;"> std::mem::{Heap}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Heap[</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">].</span><span style="color:#79B8FF;">new</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">    i.</span><span style="color:#79B8FF;">set</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">20</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(i.</span><span style="color:#79B8FF;">get</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">    i.</span><span style="color:#79B8FF;">free</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="with-integrated-jule" tabindex="-1">With Integrated Jule <a class="header-anchor" href="#with-integrated-jule" aria-label="Permalink to &quot;With Integrated Jule&quot;">​</a></h2><p>The standard library part of Integrated Jule provides various functions for memory management methods provided by C/C++. This method is based entirely on raw pointers and is quite unsafe.</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">use</span><span style="color:#E1E4E8;"> integrated </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> std::jule::integrated</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">unsafe</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> integrated::new[</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">]()</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">20</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">i)</span></span>
<span class="line"><span style="color:#E1E4E8;">        integrated::delete[</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">](i)</span></span>
<span class="line"><span style="color:#E1E4E8;">        i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div>`,9),o=[p];function t(r,c,i,E,m,y){return a(),n("div",null,o)}const b=s(l,[["render",t]]);export{d as __pageData,b as default};
