import{_ as e,o as s,c as a,Q as n}from"./chunks/framework.7cd3ab18.js";const b=JSON.parse('{"title":"std::process","description":"","frontmatter":{},"headers":[],"relativePath":"std/process.md","filePath":"std/process.md"}'),o={name:"std/process.md"},t=n(`<h1 id="std-process" tabindex="-1">std::process <a class="header-anchor" href="#std-process" aria-label="Permalink to &quot;std::process&quot;">​</a></h1><h2 id="type-aliases" tabindex="-1">Type Aliases <a class="header-anchor" href="#type-aliases" aria-label="Permalink to &quot;Type Aliases&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> Pid: </span><span style="color:#F97583;">int</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Type of a process id.</p><h2 id="functions" tabindex="-1">Functions <a class="header-anchor" href="#functions" aria-label="Permalink to &quot;Functions&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#79B8FF;">exit</span><span style="color:#E1E4E8;">(code: </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Causes the current program to exit with the given status code.<br> Conventionally, code zero indicates success, non-zero an error.</p><h2 id="structs" tabindex="-1">Structs <a class="header-anchor" href="#structs" aria-label="Permalink to &quot;Structs&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">pub</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> Cmd {</span></span>
<span class="line"><span style="color:#E1E4E8;">    args: []</span><span style="color:#F97583;">str</span></span>
<span class="line"><span style="color:#E1E4E8;">    env:  []</span><span style="color:#F97583;">str</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Cmd runs a command in the operating system. There is no pipe for the output of the command, so any output will appear on the screen.</p><p>After a cmd is spawned, the process must be terminated before it can be used again. Cmd does not follow this. That&#39;s why you need to let it know this with methods such as <code>kill</code> or <code>wait</code>.</p><p><strong>Static Fields:</strong></p><p><code>const NPID: Pid</code><br> Process id that not spawned.</p><p><strong>Methods:</strong></p><p><code>static fn new(file: str): &amp;Cmd</code><br> Returns new instance of command for file descriptor.</p><p><code>fn pid(self): Pid</code><br> Returns PID (process id). <br> Returns NPID if process not spawned.</p><p><code>fn file(self): str</code><br> Returns file descriptor.</p><p><code>fn spawn(mut self)!</code><br> Spawns process.</p><p><code>fn kill(mut self)!</code><br> Kills process. <br> Fails if process is not alive.</p><p><code>fn wait(mut self)!: int</code><br> Waits complete for running of process. <br> Returns exit code of process.</p><h2 id="enums" tabindex="-1">Enums <a class="header-anchor" href="#enums" aria-label="Permalink to &quot;Enums&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">enum</span><span style="color:#E1E4E8;"> ProcessError</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Process error codes.</p><p><strong>Fields:</strong></p><ul><li><code>Denied</code>: Permission is not enough</li><li><code>Loop</code>: Too many symbolic links were encountered in translating path or file</li><li><code>LongPath</code>: The length of the path argument exceeds maxium path length or a pathname component is longer than maximum name length</li><li><code>NotExist</code>: One or more components of the new process path name of the file do not exist or is a null pathname</li><li><code>NotDir</code>: A component of the new process path of the file prefix is not a directory</li><li><code>Signal</code>: A signal was caught during the execution</li><li><code>SyncIO</code>: The new process image file has the appropriate permission and has a recognized executable binary format, but the system does not support execution of a file with this format</li><li><code>Busy</code>: The new process image file is a pure procedure (shared text) file that is currently open for writing by some process</li><li><code>BadFile</code>: The argument is not a valid file descriptor.</li><li><code>NotExec</code>: The new process image file has the appropriate access permission but is not in the proper format</li><li><code>NoLink</code>: The path points to a remote machine and the link to that machine is no longer active</li><li><code>Big</code>: The number of bytes in the new process&#39;s argument list is greater than the system-imposed limit of maximum argument bytes</li></ul>`,25),r=[t];function i(l,p,c,d,u,h){return s(),a("div",null,r)}const f=e(o,[["render",i]]);export{b as __pageData,f as default};
