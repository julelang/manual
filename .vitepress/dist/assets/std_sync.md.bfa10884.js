import{_ as e,o as t,c as s,Q as o}from"./chunks/framework.7cd3ab18.js";const m=JSON.parse('{"title":"std::sync","description":"","frontmatter":{},"headers":[],"relativePath":"std/sync.md","filePath":"std/sync.md"}'),n={name:"std/sync.md"},a=o('<h1 id="std-sync" tabindex="-1">std::sync <a class="header-anchor" href="#std-sync" aria-label="Permalink to &quot;std::sync&quot;">​</a></h1><h2 id="structs" tabindex="-1">Structs <a class="header-anchor" href="#structs" aria-label="Permalink to &quot;Structs&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> WaitGroup</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Do not copy an instance of WaitGroup, use a ref or pointer instead.</p><p>usage: in main thread: wg: std::sync::WaitGroup<br> &quot;wg.add(delta)&quot; before starting tasks with &quot;co ...&quot;<br> &quot;wg.wait()&quot; to wait for all tasks to have finished</p><p>in each parallel job:<br> &quot;wg.done()&quot; when finished</p><p><strong>Methods:</strong></p><p><code>fn add(mut self, delta: int)</code> <br> Increments (+delta) or decrements (-delta) task count by delta and unblocks any wait() calls if task count becomes zero. Panics if task count reaches below zero.</p><p><code>fn done(mut self)</code> <br> Decrements the WaitGroup counter by one.</p><p><code>fn wait(mut self)</code> <br> Blocks until all tasks are done (task count becomes zero)</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> Mutex</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Muxtex is a primitive used to protect memory in multi-threading situations such as concurrent access.</p><p>If you try to lock an already locked mutex again in the same thread or exhibit similar behavior, a system signal is likely to occur.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p><strong>Implemented Traits</strong></p><ul><li>Dispose</li></ul></div><p><strong>Methods:</strong></p><p><code>static fn new(): &amp;Mutex</code><br> Returns new initialized ready-for-use Mutex.</p><p><code>fn lock(self)</code><br> Locks the mutex. If the mutex is locked by another thread, it stops the execution of the algorithm to seize it and waits to lock the mutex.</p><p><code>fn unlock(self)</code><br> Unlock the mutex you locked and make it open to locking by the thread.</p><p><code>fn try_lock(self): bool</code><br> Try locking the mutex. But unlike the lock method, it just tries to lock instead of waiting to lock. Returns true if the locking was successful, false otherwise.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> once</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Once is an object that will perform exactly one action. A Once must not be copied after first use.</p><p><strong>Methods:</strong></p><p><code>fn do(self, f: fn())</code><br> Calls the function f if and only if do is being called for the first time for this instance of Once. In other words, given <code>let once = Once{}</code></p><p>if <code>once.do(f)</code> is called multiple times, only the first call will invoke f, even if f has a different value in each invocation. A new instance of Once is required for each function to execute.</p><p>do is intended for initialization that must be run exactly once. Since f is niladic, it may be necessary to use a function literal to capture the arguments to a function to be invoked by do:</p><p><code>config.once.do(func() { config.init(filename) })</code></p><p>Because no call to do returns until the one call to f returns, if f causes do to be called, it will deadlock.</p><p>If f panics, do considers it to have returned; future calls of do return without calling f.</p>',30),i=[a];function c(l,r,d,u,p,f){return t(),s("div",null,i)}const b=e(n,[["render",c]]);export{m as __pageData,b as default};
