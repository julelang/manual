import{_ as s,o as a,c as n,Q as e}from"./chunks/framework.7cd3ab18.js";const d=JSON.parse('{"title":"Mutability","description":"","frontmatter":{},"headers":[],"relativePath":"memory/mutability.md","filePath":"memory/mutability.md"}'),l={name:"memory/mutability.md"},t=e(`<h1 id="mutability" tabindex="-1">Mutability <a class="header-anchor" href="#mutability" aria-label="Permalink to &quot;Mutability&quot;">​</a></h1><p>Mutability is the opposite of immutability. Mutable memory areas are allowed to be changed. It must be specified that a identified memory area is mutable, otherwise every identified memory area is considered immutable. Mutability for an identified field is achieved using the <code>mut</code> keyword.</p><h2 id="mutable-variables" tabindex="-1">Mutable Variables <a class="header-anchor" href="#mutable-variables" aria-label="Permalink to &quot;Mutable Variables&quot;">​</a></h2><p>Let&#39;s learn to say how we want a variable that is immutable by default to be mutable. The keyword <code>mut</code> is used for this. Before defining a variable, declare it mutable with this keyword. Then you will have a mutable variable.</p><p>But before that, let&#39;s make a deliberate mistake to better understand immutability:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">20</span></span>
<span class="line"><span style="color:#E1E4E8;">    x</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(x)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>The example above is absolutely wrong. Because the variable <code>x</code> we have is an immutable variable. And the <code>x++</code> statement definitely breaks immutability. In this case, compiler will give error. Now let&#39;s repeat the same example using a mutable variable.</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">20</span></span>
<span class="line"><span style="color:#E1E4E8;">    x</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(x)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Currently we want our variable as mutable so the compiler doesn&#39;t object to anything.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>All literals and received pointers are considered mutable.</p></div><h2 id="mutable-structures" tabindex="-1">Mutable Structures <a class="header-anchor" href="#mutable-structures" aria-label="Permalink to &quot;Mutable Structures&quot;">​</a></h2><p>Mutable structures are risky structures that can break immutability when directly copied. For a structure to be mutable, one of its fields must have an explicitly mutable data type. When a struct is mutable, it loses its ability to be copied. In this case, if you try to assign an immutable mutable struct instance to a mutable definition, you will fail because there is no copy and you risk breaking immutability.</p><p>See the example below for better understanding:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> Wrapper {</span></span>
<span class="line"><span style="color:#E1E4E8;">    slc: []</span><span style="color:#F97583;">int</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Wrapper{slc: [</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">]}</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> y </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> x</span></span>
<span class="line"><span style="color:#E1E4E8;">    y.slc[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">89</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(x.slc[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(y.slc[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>This structure is a mutable structure because it has a field with a mutable type. The slice that the structure contains is mutable when the structure is copied, and if the main structure is immutable, it risks this immutability of the structure. This is because the mutable copy points to the same address and the changes will affect the other copy.</p><p>The variable <code>x</code> in the example shows the case of keeping the mutable structure in an immutable variable. Then the <code>x</code> variable is copied and assigned to the mutable <code>y</code> variable, but this is a risky and unsafe operation as explained.</p><p>You can derive <code>Clone</code> to solve this problem.</p><p>For example:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#79B8FF;">#derive</span><span style="color:#E1E4E8;"> Clone</span></span>
<span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> Wrapper {</span></span>
<span class="line"><span style="color:#E1E4E8;">    slc: []</span><span style="color:#F97583;">int</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Wrapper{slc: [</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">]}</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> y </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">clone</span><span style="color:#E1E4E8;">(x)</span></span>
<span class="line"><span style="color:#E1E4E8;">    y.slc[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">89</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(x.slc[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(y.slc[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>See <a href="/compiler/deriving.html">deriving</a> page for more information about <code>Clone</code> derive.</p><h2 id="interior-mutability" tabindex="-1">Interior Mutability <a class="header-anchor" href="#interior-mutability" aria-label="Permalink to &quot;Interior Mutability&quot;">​</a></h2><p>When an instance of a struct is immutable, you cannot use it with mutable methods because this compromises its immutability guarantee. However, you may still need to change the fields of an immutable structure. For this you need to use interior mutability. Since you cannot call a mutable method, your method will remain immutable, but thanks to interior mutability, you will be able to obtain the fields you want as mutable.</p><p>It is recommended that fields within interior mutability not be public, although the compiler leaves this to the discretion of the developer. Because when interior mutability fields vary in an immutable instance, the developer using this immutable copy may encounter a change even though he or she does not expect a change on the copy. Therefore, if fields within interior mutability need to be accessible, it is recommended to use wrapper methods.</p><p>Now let&#39;s take a look at how interior mutability is achieved. Actually, this is a pretty simple. If you are a developer who has used C++ before, you may be familiar with the mutable keyword in this regard. Similarly, Jule uses the already existing keyword mut for mutability. For interior mutability, the relevant field must be declared with the mut keyword. This means that field can exhibit interior mutability.</p><p>For example:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> MyStruct {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> x: </span><span style="color:#F97583;">int</span></span>
<span class="line"><span style="color:#E1E4E8;">    y: </span><span style="color:#F97583;">int</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>In this example, the mutability of the <code>y</code> field is fully responsive. However, the variable <code>x</code> exhibits interior mutability. That&#39;s why it can be changed in methods without the need for <code>mut self</code> receiver parameter.</p><p>The point that should not be forgotten in this regard is that even if there is interior mutability, this field cannot be changed from outside the structure with an immutable instance. Interior mutability only applies inside the structure itself.</p><h3 id="traits" tabindex="-1">Traits <a class="header-anchor" href="#traits" aria-label="Permalink to &quot;Traits&quot;">​</a></h3><p>If there is a mutable <code>sel</code>f receiver in the trait&#39;s methods, it cannot be used mutably when the trait is immutable. The reason for this is clearly due to the risk of calling a mutable method of the structure it contains.</p><p>If a trait contains a mutable structure and you get it by casting, this is not considered a problem even if it is an immutable trait. The structure stored by the trait is within the scope of interior mutability for the trait. So, when you obtain that structure, you can take it as mutable and this will not cause any problems.</p><p>Trait ensures that only the methods it provides directly are used according to the immutability rule.</p><p>For example:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> PI </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3.14159</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">trait</span><span style="color:#E1E4E8;"> Shape {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">area</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">self</span><span style="color:#E1E4E8;">): </span><span style="color:#F97583;">f64</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> Circle {</span></span>
<span class="line"><span style="color:#E1E4E8;">    r: </span><span style="color:#F97583;">f64</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">impl</span><span style="color:#E1E4E8;"> Shape </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> Circle {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">area</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">self</span><span style="color:#E1E4E8;">): </span><span style="color:#F97583;">f64</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">ret</span><span style="color:#E1E4E8;"> PI </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">self</span><span style="color:#E1E4E8;">.r </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">self</span><span style="color:#E1E4E8;">.r</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s: Shape </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">Circle{r: </span><span style="color:#79B8FF;">12</span><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(s.</span><span style="color:#79B8FF;">area</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">    (</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">Circle)(s).r </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">20</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">outln</span><span style="color:#E1E4E8;">(s.</span><span style="color:#79B8FF;">area</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>In the example above, an immutable trait contains a mutable type <code>&amp;Circle</code>. We can get this by casting and change the result of the <code>area</code> method by changing the <code>r</code> field. This is because the <code>&amp;Circle</code> instance it stores has interior mutability.</p><h2 id="cloning" tabindex="-1">Cloning <a class="header-anchor" href="#cloning" aria-label="Permalink to &quot;Cloning&quot;">​</a></h2><p>You may need to have deep copies for various reasons (for example assigning mutable struct in immutable variable to mutable variable). You can use the built-in <code>clone</code> function to do this. The <code>clone</code> function only supports some data types as input. To find out about them, you can refer to the <a href="/std/builtin.html">relevant documents</a>.</p><p>Cloning supported types and copy methods:</p><ul><li><p>Numeric Types<br> Returns copy of value.</p></li><li><p><code>str</code><br> Returns copy of value.</p></li><li><p><code>bool</code><br> Returns copy of value.</p></li><li><p><code>[]T</code><br> Clones slice with elements.<br> Returns new independent mutable slice.</p></li><li><p><code>[...]T</code><br> Clones array with elements.<br> Returns new independent mutable array.</p></li><li><p><code>[K:V]</code><br> Clones map&#39;s keys and values.<br> Returns new independent mutable map.</p></li><li><p><code>&amp;T</code><br> Clones reference and type.<br> Returns new independent reference clone of expression.</p></li><li><p><code>*T</code><br> Pointers are part of the Unsafe Jule.<br> Always has risk of breaking immutability.<br> The clone function just returns copy of pointer as mutable.</p></li><li><p><code>jule:derive Clone</code><br> Clones struct if derives <code>Clone</code>.<br> Returns new independent mutable struct.</p></li></ul><h3 id="cloning-cycles" tabindex="-1">Cloning Cycles <a class="header-anchor" href="#cloning-cycles" aria-label="Permalink to &quot;Cloning Cycles&quot;">​</a></h3><p>Clone cycles are a kind of illegal cycle. In cases where you risk an endless cloning cycle at runtime, the compiler will give you an illegal cycle error. Cloning cycles usually occur in nested types, in which it will try to clone itself forever, which somehow attaches to itself.</p><p>For example:</p><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#79B8FF;">#derive</span><span style="color:#E1E4E8;"> Clone</span></span>
<span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> A {</span></span>
<span class="line"><span style="color:#E1E4E8;">    b: []B</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF;">#derive</span><span style="color:#E1E4E8;"> Clone</span></span>
<span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> B {</span></span>
<span class="line"><span style="color:#E1E4E8;">    a: []A</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>The <code>A</code> struct and <code>B</code> struct in the example above have fields that reference each other. They both derive <code>Clone</code>. But this poses a risk at runtime. Because if you try to clone struct <code>A</code> and it points to a struct <code>B</code> pointing to itself, an endless cycle of cloning occurs. This is clearly a runtime risk. Therefore the compiler will not compile your code.</p>`,44),p=[t];function o(r,i,c,u,y,E){return a(),n("div",null,p)}const m=s(l,[["render",o]]);export{d as __pageData,m as default};
