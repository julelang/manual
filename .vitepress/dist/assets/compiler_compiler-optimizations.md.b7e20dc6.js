import{_ as i,o as e,c as o,Q as t}from"./chunks/framework.7cd3ab18.js";const b=JSON.parse('{"title":"Compiler Optimizations","description":"","frontmatter":{},"headers":[],"relativePath":"compiler/compiler-optimizations.md","filePath":"compiler/compiler-optimizations.md"}'),a={name:"compiler/compiler-optimizations.md"},n=t('<h1 id="compiler-optimizations" tabindex="-1">Compiler Optimizations <a class="header-anchor" href="#compiler-optimizations" aria-label="Permalink to &quot;Compiler Optimizations&quot;">​</a></h1><p>Compiler optimizations are optimizations for improving the generated object code. The way the code you write works may change depending on the optimizations, but the result you will get will remain the same. These changes are promised to provide gains in various aspects (eg runtime performance).</p><p>Compiler optimizations are turned off by default. Optimizations are enabled with options in the build command.</p><h2 id="always-enabled-optimizations" tabindex="-1">Always Enabled Optimizations <a class="header-anchor" href="#always-enabled-optimizations" aria-label="Permalink to &quot;Always Enabled Optimizations&quot;">​</a></h2><p>Some optimizations may be enabled by default and it may not be possible to disable them. These optimizations are mostly things that will not affect you if they are turned on even when you want to turn off all optimizations for your debugging.</p><h3 id="constant-optimization" tabindex="-1">Constant Optimization <a class="header-anchor" href="#constant-optimization" aria-label="Permalink to &quot;Constant Optimization&quot;">​</a></h3><p>Constant optimization, in short, is the processing of constant expressions that can be evaluated at runtime. Since processed constant values ​​represent the direct result, it helps to create code that creates less load at runtime.</p><p>Constant optimization does the following:</p><ul><li>Values ​​that can be evaluated at compile-time, such as literals and constant variables, are evaluated. For example, a <code>true == false</code> expression is evaluated at compile-time and handled as <code>false</code>. This is performed for all valid constant types such as integers, floating-points, and strings.</li><li>May choose the ternary operator result whenever possible.</li><li>Indexing of constant strings, and slice literals are evaluated if the indexing is done with a constant expression.</li><li>Slicing of constant strings is evaluated if the indexes are done with a constant expression.</li></ul><h2 id="optimization-options" tabindex="-1">Optimization Options <a class="header-anchor" href="#optimization-options" aria-label="Permalink to &quot;Optimization Options&quot;">​</a></h2><p><code>--opt-copy</code> <br> It reduces copying operations whenever possible.</p><ul><li>Once proven safe, it reduces the cost of copying in foreach iterations. Having immutability is very effective to have this optimization.</li><li>Refers to data instead of copying when using lvalue in match statements.</li></ul><hr><p><code>--opt-deadcode</code> <br> It eliminates dead codes (unused) from object code.</p><ul><li>Eliminates dead globals.</li><li>Eliminates dead functions.</li><li>Eliminates followed statements of the return statement.</li><li>Eliminates followed statements of the built-in <code>panic</code> function calls.</li><li>Eliminates followed statements of the built-in <code>error</code> function calls.</li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Experimental optimization, compilation problems may occur.</p></div><hr><p><code>--opt-append</code> <br> Enable special optimizations for built-in <code>append</code> function.</p><ul><li>It prevents the allocating and destruction of a new slice by adding slice literals element-by-element if append used at single assignment statement.</li></ul><hr><p><code>--opt-math</code> <br> Enable optimizations for mathematical operations.</p><ul><li>Skip the divide-by-zero check for division when operand is constant.</li><li>Skip the divide-by-zero check for modulo when operand is constant.</li></ul><hr><p><code>--opt-access</code> <br> Enable optimizations for memory acessing.</p><ul><li>Skip safety checkings such as boundary checking if accessed to array via constant index expression.</li><li>If in a foreach iteration the iterated variable referred to by a immutable index variable is indexed, it is optimized as direct access and the cost of safety measures such as boundary checking is bypassed.<br><br> This optimization is only enabled when the iterated varaible is: array, immutable slice, or immutable string.</li></ul><hr><p><code>--opt-inline</code> <br> Enable optimizatons for inlining.</p><ul><li>The IR is generated includes encourage inline optimizations of the backend compiler.</li></ul><hr><p><code>--opt-ptr</code> <br> Enable optimizations for pointers.</p><ul><li>Immediate pointer simplifies dereferencing statements. For example, if the address of the variable <code>x</code> is accessed immediately after its pointer is obtained, it directly simplifies it to <code>x</code>. This optimization can be useful in eliminating the cost of expressions used to break immutability with Unsafe Jule.</li></ul><h2 id="optimization-levels" tabindex="-1">Optimization Levels <a class="header-anchor" href="#optimization-levels" aria-label="Permalink to &quot;Optimization Levels&quot;">​</a></h2><p>It can be a hassle to pass all flags one by one to send most optimizations to the compiler. To make this easier, compiler optimization levels have been created where you don&#39;t have to pass additional flags in most cases. These optimization levels are flag packages that activate various optimizations.</p><p>Here is the option for using optimization level:</p><p><code>--opt &lt;level&gt;</code> <br> Set optimization level to <code>&lt;level&gt;</code>.</p><p>The optimization levels are as follows:</p><ul><li><code>L0</code>: disable all compiler optimizations (default value of JuleC)</li><li><code>L1</code>: passes <code>--opt-copy</code>, <code>--opt-deadcode</code>, <code>--opt-append</code>, <code>--opt-math</code>, <code>--opt-access</code>, <code>--opt-inline</code>, and <code>--opt-ptr</code></li></ul><h2 id="production-compilation" tabindex="-1">Production Compilation <a class="header-anchor" href="#production-compilation" aria-label="Permalink to &quot;Production Compilation&quot;">​</a></h2><p>Production compilation is a compiler feature that must be enabled separately using the <code>-p</code> or <code>--production</code> flag. It behaves differently than optimization options whic is enabled with <code>--opt</code> options.</p><p>Production compilation may have an impact on IR rendering, but in addition it has an impact on backend compilers. By default, your compiler compiles code to make it suitable for debugging and testing. This allows you to get faster compile times and a better debugging experience. In the common scenario for Production, you only do one build, when you are sure everything is ready. That&#39;s why production builds are rarer and not the default option.</p><p>When you enable production compilation, it provides improvements that optimization options cannot provide. It can cause some changes to the IR and additionally prompts your backend compiler to compile the IR code more efficiently. In this way, significantly optimized faster programs can be obtained by using optimization options and production compilation together.</p><p>Pros of enabling production compilation:</p><ul><li>Remove assert calls.</li><li>Disable assertions of backend compiler.</li><li>Use maximum optimization level of backend compiler.</li><li>Additional optimizations that vary by backend compiler.</li><li>Do not use frame pointer.</li></ul><p>Cons of enabling production compilation:</p><ul><li>Harder debugging.</li><li>Longer compile time.</li><li>Some subtle bugs can only occur with optimizations enabled by production compilation and can cause the executable to behave differently than expected. It is mostly related to the codes you write or use when using C/C++ interoperability.</li><li>If the backend compiler you are using has some new optimizations or contains bugs, your code may run fast but not as expected. These types of optimization-related bugs can be difficult to track down.</li></ul><h2 id="optimization-options-vs-production-compilation" tabindex="-1">Optimization Options vs Production Compilation <a class="header-anchor" href="#optimization-options-vs-production-compilation" aria-label="Permalink to &quot;Optimization Options vs Production Compilation&quot;">​</a></h2><p>Optimization options and production compilation focus on different things. Optimization options focus on achieving optimizations on the IR generated by your compiler. It doesn&#39;t interfere with anything else. Production compilation now focuses on compiling the IR you get when you want to compile a software that is ready for production. Production compiler never enables optimization flag. It focuses solely on compiling IR for production. If necessary, IR can remove things that are not required for production, but these changes are not improvements provided by optimization options. For best performance and optimization in production, optimization options and production compilation should be used together.</p><h3 id="optimization-options-1" tabindex="-1">Optimization Options <a class="header-anchor" href="#optimization-options-1" aria-label="Permalink to &quot;Optimization Options&quot;">​</a></h3><ul><li>Focus to code generation optimizations, better IR.</li><li>Never do not touch backend compiler.</li></ul><h3 id="production-compilation-1" tabindex="-1">Production Compilation <a class="header-anchor" href="#production-compilation-1" aria-label="Permalink to &quot;Production Compilation&quot;">​</a></h3><ul><li>Focus to faster executables as possible.</li><li>Optimize code generation for better IR if necessary.</li><li>Enable optimizations of backend compiler.</li></ul>',51),s=[n];function l(r,p,c,d,m,u){return e(),o("div",null,s)}const f=i(a,[["render",l]]);export{b as __pageData,f as default};
