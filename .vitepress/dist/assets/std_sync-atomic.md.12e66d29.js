import{_ as e,o as r,c as a,Q as s}from"./chunks/framework.7cd3ab18.js";const b=JSON.parse('{"title":"std::sync::atomic","description":"","frontmatter":{},"headers":[],"relativePath":"std/sync-atomic.md","filePath":"std/sync-atomic.md"}'),o={name:"std/sync-atomic.md"},t=s('<h1 id="std-sync-atomic" tabindex="-1">std::sync::atomic <a class="header-anchor" href="#std-sync-atomic" aria-label="Permalink to &quot;std::sync::atomic&quot;">​</a></h1><h2 id="functions" tabindex="-1">Functions <a class="header-anchor" href="#functions" aria-label="Permalink to &quot;Functions&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> swap[T](</span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">addr: T, new: T, order: MemoryOrder): (old: T)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Atomically stores new into addr and returns the previous addr value. Only integer types are supported.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> compare_swap[T](</span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">addr: T, old: T, new: T, order: MemoryOrder): (swapped: </span><span style="color:#F97583;">bool</span><span style="color:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Executes the compare-and-swap operation for value. Only integer types are supported.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> add[T](</span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">addr: T, delta: T, order: MemoryOrder): (old: T)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Atomically adds delta to addr and returns the previous addr value. Only integer types are supported.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> load[T](</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">addr: T, order: MemoryOrder): T</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Atomically loads addr. Only integer types are supported.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">fn</span><span style="color:#E1E4E8;"> store[T](</span><span style="color:#F97583;">mut</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">addr: T, val: T, order: MemoryOrder)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Atomically stores val into addr. Only integer types are supported.</p><h2 id="structures" tabindex="-1">Structures <a class="header-anchor" href="#structures" aria-label="Permalink to &quot;Structures&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> AtomicI8</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Type alias for private wrapper structure for i8 type.</p><p><strong>Methods:</strong></p><p><code>static fn new(n: i8): AtomicInt</code> <br> Returns new atomic instance for type with initializer value.</p><p><code>fn swap(mut self, new: i8, order: MemoryOrder): (old: i8)</code><br> Atomically stores new value and returns the previous value.</p><p><code>fn compare_swap(mut self, old: i8, new: i8, order: MemoryOrder): (swapped: bool)</code><br> Executes the compare-and-swap operation.</p><p><code>fn add(mut self, delta: i8, order: MemoryOrder): (old: i8)</code><br> Atomically adds delta to value and returns the previous value.</p><p><code>fn load(self, order: MemoryOrder): i8</code><br> Atomically reads and returns value.</p><p><code>fn store(mut self, val: i8, order: MemoryOrder)</code><br> Atomically assigns to value.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> AtomicI16</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Type alias for private wrapper structure for i16 type.</p><p><strong>Methods:</strong></p><p><code>static fn new(n: i16): AtomicInt</code> <br> Returns new atomic instance for type with initializer value.</p><p><code>fn swap(mut self, new: i16, order: MemoryOrder): (old: i16)</code><br> Atomically stores new value and returns the previous value.</p><p><code>fn compare_swap(mut self, old: i16, new: i16, order: MemoryOrder): (swapped: bool)</code><br> Executes the compare-and-swap operation.</p><p><code>fn add(mut self, delta: i16, order: MemoryOrder): (old: i16)</code><br> Atomically adds delta to value and returns the previous value.</p><p><code>fn load(self, order: MemoryOrder): i16</code><br> Atomically reads and returns value.</p><p><code>fn store(mut self, val: i16, order: MemoryOrder)</code><br> Atomically assigns to value.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> AtomicI32</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Type alias for private wrapper structure for i32 type.</p><p><strong>Methods:</strong></p><p><code>static fn new(n: i32): AtomicInt</code> <br> Returns new atomic instance for type with initializer value.</p><p><code>fn swap(mut self, new: i32, order: MemoryOrder): (old: i32)</code><br> Atomically stores new value and returns the previous value.</p><p><code>fn compare_swap(mut self, old: i32, new: i32, order: MemoryOrder): (swapped: bool)</code><br> Executes the compare-and-swap operation.</p><p><code>fn add(mut self, delta: i32, order: MemoryOrder): (old: i32)</code><br> Atomically adds delta to value and returns the previous value.</p><p><code>fn load(self, order: MemoryOrder): i32</code><br> Atomically reads and returns value.</p><p><code>fn store(mut self, val: i32, order: MemoryOrder)</code><br> Atomically assigns to value.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> AtomicI64</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Type alias for private wrapper structure for i64 type.</p><p><strong>Methods:</strong></p><p><code>static fn new(n: i64): AtomicInt</code> <br> Returns new atomic instance for type with initializer value.</p><p><code>fn swap(mut self, new: i64, order: MemoryOrder): (old: i64)</code><br> Atomically stores new value and returns the previous value.</p><p><code>fn compare_swap(mut self, old: i64, new: i64, order: MemoryOrder): (swapped: bool)</code><br> Executes the compare-and-swap operation.</p><p><code>fn add(mut self, delta: i64, order: MemoryOrder): (old: i64)</code><br> Atomically adds delta to value and returns the previous value.</p><p><code>fn load(self, order: MemoryOrder): i64</code><br> Atomically reads and returns value.</p><p><code>fn store(mut self, val: i64, order: MemoryOrder)</code><br> Atomically assigns to value.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> AtomicInt</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Type alias for private wrapper structure for int type.</p><p><strong>Methods:</strong></p><p><code>static fn new(n: int): AtomicInt</code> <br> Returns new atomic instance for type with initializer value.</p><p><code>fn swap(mut self, new: int, order: MemoryOrder): (old: int)</code><br> Atomically stores new value and returns the previous value.</p><p><code>fn compare_swap(mut self, old: int, new: int, order: MemoryOrder): (swapped: bool)</code><br> Executes the compare-and-swap operation.</p><p><code>fn add(mut self, delta: int, order: MemoryOrder): (old: int)</code><br> Atomically adds delta to value and returns the previous value.</p><p><code>fn load(self, order: MemoryOrder): int</code><br> Atomically reads and returns value.</p><p><code>fn store(mut self, val: int, order: MemoryOrder)</code><br> Atomically assigns to value.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> AtomicU8</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Type alias for private wrapper structure for u8 type.</p><p><strong>Methods:</strong></p><p><code>static fn new(n: u8): AtomicInt</code> <br> Returns new atomic instance for type with initializer value.</p><p><code>fn swap(mut self, new: u8, order: MemoryOrder): (old: u8)</code><br> Atomically stores new value and returns the previous value.</p><p><code>fn compare_swap(mut self, old: u8, new: u8, order: MemoryOrder): (swapped: bool)</code><br> Executes the compare-and-swap operation.</p><p><code>fn add(mut self, delta: u8, order: MemoryOrder): (old: u8)</code><br> Atomically adds delta to value and returns the previous value.</p><p><code>fn load(self, order: MemoryOrder): u8</code><br> Atomically reads and returns value.</p><p><code>fn store(mut self, val: u8, order: MemoryOrder)</code><br> Atomically assigns to value.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> AtomicU16</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Type alias for private wrapper structure for u16 type.</p><p><strong>Methods:</strong></p><p><code>static fn new(n: u16): AtomicInt</code> <br> Returns new atomic instance for type with initializer value.</p><p><code>fn swap(mut self, new: u16, order: MemoryOrder): (old: u16)</code><br> Atomically stores new value and returns the previous value.</p><p><code>fn compare_swap(mut self, old: u16, new: u16, order: MemoryOrder): (swapped: bool)</code><br> Executes the compare-and-swap operation.</p><p><code>fn add(mut self, delta: u16, order: MemoryOrder): (old: u16)</code><br> Atomically adds delta to value and returns the previous value.</p><p><code>fn load(self, order: MemoryOrder): u16</code><br> Atomically reads and returns value.</p><p><code>fn store(mut self, val: u16, order: MemoryOrder)</code><br> Atomically assigns to value.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> AtomicU32</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Type alias for private wrapper structure for u32 type.</p><p><strong>Methods:</strong></p><p><code>static fn new(n: u32): AtomicInt</code> <br> Returns new atomic instance for type with initializer value.</p><p><code>fn swap(mut self, new: u32, order: MemoryOrder): (old: u32)</code><br> Atomically stores new value and returns the previous value.</p><p><code>fn compare_swap(mut self, old: u32, new: u32, order: MemoryOrder): (swapped: bool)</code><br> Executes the compare-and-swap operation.</p><p><code>fn add(mut self, delta: u32, order: MemoryOrder): (old: u32)</code><br> Atomically adds delta to value and returns the previous value.</p><p><code>fn load(self, order: MemoryOrder): u32</code><br> Atomically reads and returns value.</p><p><code>fn store(mut self, val: u32, order: MemoryOrder)</code><br> Atomically assigns to value.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> AtomicU64</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Type alias for private wrapper structure for u64 type.</p><p><strong>Methods:</strong></p><p><code>static fn new(n: u64): AtomicInt</code> <br> Returns new atomic instance for type with initializer value.</p><p><code>fn swap(mut self, new: u64, order: MemoryOrder): (old: u64)</code><br> Atomically stores new value and returns the previous value.</p><p><code>fn compare_swap(mut self, old: u64, new: u64, order: MemoryOrder): (swapped: bool)</code><br> Executes the compare-and-swap operation.</p><p><code>fn add(mut self, delta: u64, order: MemoryOrder): (old: u64)</code><br> Atomically adds delta to value and returns the previous value.</p><p><code>fn load(self, order: MemoryOrder): u64</code><br> Atomically reads and returns value.</p><p><code>fn store(mut self, val: u64, order: MemoryOrder)</code><br> Atomically assigns to value.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> AtomicUint</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Type alias for private wrapper structure for uint type.</p><p><strong>Methods:</strong></p><p><code>static fn new(n: uint): AtomicUint</code> <br> Returns new atomic instance for type with initializer value.</p><p><code>fn swap(mut self, new: uint, order: MemoryOrder): (old: uint)</code><br> Atomically stores new value and returns the previous value.</p><p><code>fn compare_swap(mut self, old: uint, new: uint, order: MemoryOrder): (swapped: bool)</code><br> Executes the compare-and-swap operation.</p><p><code>fn add(mut self, delta: uint, order: MemoryOrder): (old: uint)</code><br> Atomically adds delta to value and returns the previous value.</p><p><code>fn load(self, order: MemoryOrder): uint</code><br> Atomically reads and returns value.</p><p><code>fn store(mut self, val: uint, order: MemoryOrder)</code><br> Atomically assigns to value.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> AtomicUintptr</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Type alias for private wrapper structure for uintptr type.</p><p><strong>Methods:</strong></p><p><code>static fn new(n: uintptr): AtomicUintptr</code> <br> Returns new atomic instance for type with initializer value.</p><p><code>fn swap(mut self, new: uintptr, order: MemoryOrder): (old: uintptr)</code><br> Atomically stores new value and returns the previous value.</p><p><code>fn compare_swap(mut self, old: uintptr, new: uintptr, order: MemoryOrder): (swapped: bool)</code><br> Executes the compare-and-swap operation.</p><p><code>fn add(mut self, delta: uintptr, order: MemoryOrder): (old: uintptr)</code><br> Atomically adds delta to value and returns the previous value.</p><p><code>fn load(self, order: MemoryOrder): uintptr</code><br> Atomically reads and returns value.</p><p><code>fn store(mut self, val: uintptr, order: MemoryOrder)</code><br> Atomically assigns to value.</p><h2 id="enums" tabindex="-1">Enums <a class="header-anchor" href="#enums" aria-label="Permalink to &quot;Enums&quot;">​</a></h2><p><code>enum MemoryOrder</code></p><p>Memory order for atomic operations. <br> Specifies how memory accesses.</p><p><strong>Fields:</strong></p><ul><li><code>Relaxed</code>: The weakest memory order. There no synchronization or ordering on read/write access. Only the operation is guaranteed to be atomic. Usually performs fastest atomicity performance.</li><li><code>Acquire</code>: Combined with a load, if the loaded value was written by a store operation with a Release or stronger order, all subsequent operations are ordered after that store. Especially all subsequent uploads will see the data written before the repository.</li><li><code>Release</code>: When combined with a store, all previous operations are ordered with the Acquire or stronger order before any load of that value. In particular, all previous writes become visible to all threads that perform an Acquire or stronger load of this value.</li><li><code>AcqRel</code>: Acquire and Release combined. Aka acquire/release. For loads it uses Acquire, for stores it uses Release ordering.</li><li><code>SeqCst</code>: Default memory order for most things. Aka sequentially consistent. Operations are sequenced consistently.</li></ul>',131),n=[t];function l(p,d,i,c,u,m){return r(),a("div",null,n)}const v=e(o,[["render",l]]);export{b as __pageData,v as default};
