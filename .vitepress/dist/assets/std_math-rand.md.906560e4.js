import{_ as e,o as n,c as a,Q as s}from"./chunks/framework.7cd3ab18.js";const g=JSON.parse('{"title":"std::math::rand","description":"","frontmatter":{},"headers":[],"relativePath":"std/math-rand.md","filePath":"std/math-rand.md"}'),t={name:"std/math-rand.md"},r=s('<h1 id="std-math-rand" tabindex="-1">std::math::rand <a class="header-anchor" href="#std-math-rand" aria-label="Permalink to &quot;std::math::rand&quot;">​</a></h1><h2 id="type-aliases" tabindex="-1">Type Aliases <a class="header-anchor" href="#type-aliases" aria-label="Permalink to &quot;Type Aliases&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> Seed: </span><span style="color:#F97583;">uint</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Integer type of random seeds.</p><h2 id="structures" tabindex="-1">Structures <a class="header-anchor" href="#structures" aria-label="Permalink to &quot;Structures&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> Rand</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>This structure implements a type of pseudo random number generator (PRNG). The seed must be given manually for each instance.</p><p>Seeds:</p><ul> Seed is a number of seeds used to simulate randomness. The order and numbers produced vary depending on the seed. Since PRNGs are inherently deterministic, using a fixed seed means your program will generate the same numbers every time. <p>If you want to achieve randomness somehow, use a variable seed. A simple solution for seeds that will create the illusion of randomness is to use time. Unix-time seconds could be a simple seed solution.</p></ul><p>Ranges:</p><ul> This structure by default provides a function to simulate randomness between two numbers. But a way to do this can be suggested. <p>Here is basic range formula: <br>   <code>ƒ(x) -&gt; rand.nextn(max - min) + min</code></p><p>With this formula, randomness can be made in the <code>[min, max)</code> range.</p></ul><p><strong>Methods:</strong></p><p><code>static fn new(seed: Seed): &amp;Rand</code><br> Returns new PRNG for seed.</p><hr><p><code>fn next63(mut self): i64</code><br> Returns a non-genative pseudo-random 63-bit signed integer as an 64-bit signed integer.</p><hr><p><code>fn next31(mut self): i32</code><br> Returns a non-genative pseudo-random 31-bit signed integer as an 31-bit signed integer.</p><hr><p><code>fn nextn63(mut self, n: i64): i64</code><br> Returns a non-genative pseudo-random in <code>[0, n)</code> range 63-bit signed integer as an 64-bit signed integer. If <code>n &lt;= 0</code>, it panics.</p><hr><p><code>fn nextn31(mut self, n: i32): i32</code><br> Returns a non-genative pseudo-random in <code>[0, n)</code> range 31-bit signed integer as an 31-bit signed integer. If <code>n &lt;= 0</code>, it panics.</p><hr><p><code>fn fnext64(mut self): f64</code><br> Returns a non-genative pseudo-random in <code>[0.0, 1.0)</code> range as f64 floating-point.</p><hr><p><code>fn fnext32(mut self): f32</code><br> Returns a non-genative pseudo-random in <code>[0.0, 1.0)</code> range as f32 floating-point.</p>',25),o=[r];function d(i,c,l,p,u,m){return n(),a("div",null,o)}const b=e(t,[["render",d]]);export{g as __pageData,b as default};
