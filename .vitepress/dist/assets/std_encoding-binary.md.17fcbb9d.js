import{_ as e,o as n,c as t,Q as s}from"./chunks/framework.7cd3ab18.js";const y=JSON.parse('{"title":"std::encoding::binary","description":"","frontmatter":{},"headers":[],"relativePath":"std/encoding-binary.md","filePath":"std/encoding-binary.md"}'),i={name:"std/encoding-binary.md"},o=s('<h1 id="std-encoding-binary" tabindex="-1">std::encoding::binary <a class="header-anchor" href="#std-encoding-binary" aria-label="Permalink to &quot;std::encoding::binary&quot;">​</a></h1><h2 id="structures" tabindex="-1">Structures <a class="header-anchor" href="#structures" aria-label="Permalink to &quot;Structures&quot;">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> BigEndian</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Binary encoding implementation for big-endian order.</p><p><strong>Methods:</strong></p><p><code>static fn encode_u16(mut b: []byte, x: u16)</code><br> Encodes unsigned 16-bit integer into 2-bytes slice.</p><p><code>static fn decode_u16(b: []byte): u16</code><br> Decodes unsigned 16-bit integer from 2-bytes.</p><p><code>static fn encode_u32(mut b: []byte, x: u32)</code><br> Encodes unsigned 32-bit integer into 4-bytes slice.</p><p><code>static fn decode_u32(b: []byte): u32</code><br> Decodes unsigned 32-bit integer from 4-bytes.</p><p><code>static fn encode_u64(mut b: []byte, x: u64)</code><br> Encodes unsigned 64-bit integer into 8-bytes slice.</p><p><code>static fn decode_u64(b: []byte): u64</code><br> Decodes unsigned 64-bit integer from 8-bytes.</p><hr><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> LittleEndian</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Binary encoding implementation for little-endian order.</p><p><strong>Methods:</strong></p><p><code>static fn encode_u16(mut b: []byte, x: u16)</code><br> Encodes unsigned 16-bit integer into 2-bytes slice.</p><p><code>static fn decode_u16(b: []byte): u16</code><br> Decodes unsigned 16-bit integer from 2-bytes.</p><p><code>static fn encode_u32(mut b: []byte, x: u32)</code><br> Encodes unsigned 32-bit integer into 4-bytes slice.</p><p><code>static fn decode_u32(b: []byte): u32</code><br> Decodes unsigned 32-bit integer from 4-bytes.</p><p><code>static fn encode_u64(mut b: []byte, x: u64)</code><br> Encodes unsigned 64-bit integer into 8-bytes slice.</p><p><code>static fn decode_u64(b: []byte): u64</code><br> Decodes unsigned 64-bit integer from 8-bytes.</p>',21),d=[o];function c(a,r,b,u,p,l){return n(),t("div",null,d)}const _=e(i,[["render",c]]);export{y as __pageData,_ as default};
